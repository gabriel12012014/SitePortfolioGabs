<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio | Gabriel</title>

    <!-- SEO -->
    <meta name="description" content="Portfolio de Gabriel - Design, Ilustração, Desenvolvimento Web e Games">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Outfit:wght@400;600;700;800&display=swap"
        rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="preloader-root"></div>
    <div class="global-grain"></div>
    <header class="hero-header">
        <!-- Dither Background Effect -->
        <div id="dither-bg-root"></div>
        <!-- GridDistortion Slideshow -->
        <div id="grid-distortion-root"></div>



        <nav class="main-nav">
            <div class="logo">Gabs.</div>
            <!-- Future Navigation Items -->
        </nav>


    </header>

    <section id="work" class="work-section">
        <!-- CurvedLoop Title - Full Width -->
        <div id="curved-title-root"></div>

        <div class="container">

            <div class="filter-buttons">
                <button class="filter-btn active" data-filter="all">Todos</button>
                <button class="filter-btn" data-filter="Design">Design</button>
                <button class="filter-btn" data-filter="Ilustração">Ilustração</button>
                <button class="filter-btn" data-filter="Game Dev">Games</button>
            </div>

            <div class="project-grid" id="project-grid">
                <!-- Projects will be rendered here by JS -->
            </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="contact-section">
        <div class="container">
            <h2>Entre em contato</h2>

            <div class="contact-content">
                <a href="https://wa.me/5511999999999" target="_blank" class="whatsapp-main-btn">
                    Mande um zap!
                </a>

                <div class="contact-grid">
                    <a href="mailto:seuemail@gmail.com" class="contact-item">Email</a>
                    <a href="https://wa.me/5511999999999" target="_blank" class="contact-item">WhatsApp (Num)</a>
                    <a href="https://instagram.com/seuusuario" target="_blank" class="contact-item">Instagram</a>
                    <a href="https://itch.io/profile/seuusuario" target="_blank" class="contact-item">Itch.io</a>
                </div>
            </div>
        </div>
    </section>

    <footer class="site-footer">
        <div class="container footer-content">
            <span>Made by gabs</span>
            <span>Site feito usando a ferramenta Antigravity</span>
        </div>
    </footer>

    <!-- Crosshair Effect Root -->
    <div id="crosshair-root"></div>

    <!-- React, Babel, GSAP and Three.js CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- Crosshair Component (Babel) -->
    <script type="text/babel">
        const { useRef, useEffect, useState, useId } = React;
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        const getMousePos = (e, container) => {
            if (container) {
                const bounds = container.getBoundingClientRect();
                return { x: e.clientX - bounds.left, y: e.clientY - bounds.top };
            }
            return { x: e.clientX, y: e.clientY };
        };

        const Crosshair = ({ color = '#ff69b4', containerRef = null }) => {
            const cursorRef = useRef(null);
            const lineHorizontalRef = useRef(null);
            const lineVerticalRef = useRef(null);
            const filterXRef = useRef(null);
            const filterYRef = useRef(null);

            let mouse = { x: 0, y: 0 };

            useEffect(() => {
                const handleMouseMove = ev => {
                    mouse = getMousePos(ev, containerRef?.current);
                    if (containerRef?.current) {
                        const bounds = containerRef.current.getBoundingClientRect();
                        if (
                            ev.clientX < bounds.left ||
                            ev.clientX > bounds.right ||
                            ev.clientY < bounds.top ||
                            ev.clientY > bounds.bottom
                        ) {
                            gsap.to([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0 });
                        } else {
                            gsap.to([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0.4 });
                        }
                    }
                };

                const target = containerRef?.current || window;
                target.addEventListener('mousemove', handleMouseMove);

                const renderedStyles = {
                    tx: { previous: 0, current: 0, amt: 0.15 },
                    ty: { previous: 0, current: 0, amt: 0.15 }
                };

                gsap.set([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0 });

                const onMouseMove = () => {
                    renderedStyles.tx.previous = renderedStyles.tx.current = mouse.x;
                    renderedStyles.ty.previous = renderedStyles.ty.current = mouse.y;
                    gsap.to([lineHorizontalRef.current, lineVerticalRef.current], {
                        duration: 0.9,
                        ease: 'Power3.easeOut',
                        opacity: 0.4
                    });
                    requestAnimationFrame(render);
                    target.removeEventListener('mousemove', onMouseMove);
                };

                target.addEventListener('mousemove', onMouseMove);

                const primitiveValues = { turbulence: 0 };
                const tl = gsap.timeline({
                    paused: true,
                    onStart: () => {
                        lineHorizontalRef.current.style.filter = `url(#filter-noise-x)`;
                        lineVerticalRef.current.style.filter = `url(#filter-noise-y)`;
                    },
                    onUpdate: () => {
                        if (filterXRef.current && filterYRef.current) {
                            filterXRef.current.setAttribute('baseFrequency', primitiveValues.turbulence);
                            filterYRef.current.setAttribute('baseFrequency', primitiveValues.turbulence);
                        }
                    },
                    onComplete: () => {
                        if (lineHorizontalRef.current && lineVerticalRef.current) {
                            lineHorizontalRef.current.style.filter = lineVerticalRef.current.style.filter = 'none';
                        }
                    }
                })
                    .to(primitiveValues, {
                        duration: 0.5,
                        ease: 'power1',
                        startAt: { turbulence: 1 },
                        turbulence: 0
                    });

                const enter = () => tl.restart();
                const leave = () => tl.progress(1).kill();

                const render = () => {
                    renderedStyles.tx.current = mouse.x;
                    renderedStyles.ty.current = mouse.y;
                    for (const key in renderedStyles) {
                        renderedStyles[key].previous = lerp(
                            renderedStyles[key].previous,
                            renderedStyles[key].current,
                            renderedStyles[key].amt
                        );
                    }
                    if (lineHorizontalRef.current && lineVerticalRef.current) {
                        gsap.set(lineVerticalRef.current, { x: renderedStyles.tx.previous });
                        gsap.set(lineHorizontalRef.current, { y: renderedStyles.ty.previous });
                    }
                    requestAnimationFrame(render);
                };

                const links = containerRef?.current ? containerRef.current.querySelectorAll('a') : document.querySelectorAll('a');
                links.forEach(link => {
                    link.addEventListener('mouseenter', enter);
                    link.addEventListener('mouseleave', leave);
                });

                return () => {
                    target.removeEventListener('mousemove', handleMouseMove);
                    target.removeEventListener('mousemove', onMouseMove);
                    links.forEach(link => {
                        link.removeEventListener('mouseenter', enter);
                        link.removeEventListener('mouseleave', leave);
                    });
                };
            }, [containerRef]);

            return (
                <div
                    ref={cursorRef}
                    className="cursor"
                    style={{
                        position: containerRef ? 'absolute' : 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10000
                    }}
                >
                    <svg style={{ position: 'absolute', left: 0, top: 0, width: '100%', height: '100%' }}>
                        <defs>
                            <filter id="filter-noise-x">
                                <feTurbulence type="fractalNoise" baseFrequency="0.000001" numOctaves="1" ref={filterXRef} />
                                <feDisplacementMap in="SourceGraphic" scale="40" />
                            </filter>
                            <filter id="filter-noise-y">
                                <feTurbulence type="fractalNoise" baseFrequency="0.000001" numOctaves="1" ref={filterYRef} />
                                <feDisplacementMap in="SourceGraphic" scale="40" />
                            </filter>
                        </defs>
                    </svg>
                    <div
                        ref={lineHorizontalRef}
                        style={{
                            position: 'absolute',
                            width: '100%',
                            height: '3px',
                            background: `linear-gradient(to right, transparent, ${color} 15%, ${color} 85%, transparent)`,
                            pointerEvents: 'none',
                            transform: 'translateY(50%)',
                            opacity: 0
                        }}
                    ></div>
                    <div
                        ref={lineVerticalRef}
                        style={{
                            position: 'absolute',
                            height: '100%',
                            width: '3px',
                            background: `linear-gradient(to bottom, transparent, ${color} 15%, ${color} 85%, transparent)`,
                            pointerEvents: 'none',
                            transform: 'translateX(50%)',
                            opacity: 0
                        }}
                    ></div>
                </div>
            );
        };

        // ClickSpark Component
        const ClickSpark = ({
            sparkColor = '#ff69b4',
            sparkSize = 10,
            sparkRadius = 15,
            sparkCount = 8,
            duration = 400,
            easing = 'ease-out',
            extraScale = 1.0
        }) => {
            const canvasRef = useRef(null);
            const sparksRef = useRef([]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                return () => window.removeEventListener('resize', resizeCanvas);
            }, []);

            const easeFunc = (t) => {
                switch (easing) {
                    case 'linear': return t;
                    case 'ease-in': return t * t;
                    case 'ease-in-out': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    default: return t * (2 - t);
                }
            };

            const [resolvedColor, setResolvedColor] = useState(sparkColor);

            useEffect(() => {
                const updateColor = () => {
                    if (sparkColor.startsWith('var(')) {
                        const varName = sparkColor.match(/var\(([^)]+)\)/)[1];
                        setResolvedColor(getComputedStyle(document.documentElement).getPropertyValue(varName).trim());
                    } else {
                        setResolvedColor(sparkColor);
                    }
                };
                updateColor();
                window.addEventListener('theme-change', updateColor);
                return () => window.removeEventListener('theme-change', updateColor);
            }, [sparkColor]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                let animationId;

                const draw = (timestamp) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    sparksRef.current = sparksRef.current.filter(spark => {
                        const elapsed = timestamp - spark.startTime;
                        if (elapsed >= duration) return false;

                        const progress = elapsed / duration;
                        const eased = easeFunc(progress);

                        const distance = eased * sparkRadius * extraScale;
                        const lineLength = sparkSize * (1 - eased);

                        const x1 = spark.x + distance * Math.cos(spark.angle);
                        const y1 = spark.y + distance * Math.sin(spark.angle);
                        const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle);
                        const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);

                        ctx.strokeStyle = resolvedColor;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();

                        return true;
                    });

                    animationId = requestAnimationFrame(draw);
                };

                animationId = requestAnimationFrame(draw);

                return () => cancelAnimationFrame(animationId);
            }, [resolvedColor, sparkSize, sparkRadius, sparkCount, duration, easing, extraScale]);

            useEffect(() => {
                const handleClick = (e) => {
                    const now = performance.now();
                    const newSparks = Array.from({ length: sparkCount }, (_, i) => ({
                        x: e.clientX,
                        y: e.clientY,
                        angle: (2 * Math.PI * i) / sparkCount,
                        startTime: now
                    }));
                    sparksRef.current.push(...newSparks);
                };

                window.addEventListener('click', handleClick);
                return () => window.removeEventListener('click', handleClick);
            }, [sparkCount]);

            return (
                <canvas
                    ref={canvasRef}
                    style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10001
                    }}
                />
            );
        };

        // CurvedLoop Component
        const CurvedLoop = ({
            marqueeText = '',
            speed = 2,
            className,
            curveAmount = 400,
            direction = 'left',
            interactive = true
        }) => {
            const text = (() => {
                const hasTrailing = /\s|\u00A0$/.test(marqueeText);
                return (hasTrailing ? marqueeText.replace(/\s+$/, '') : marqueeText) + '\u00A0';
            })();

            const measureRef = useRef(null);
            const textPathRef = useRef(null);
            const pathRef = useRef(null);
            const [spacing, setSpacing] = useState(0);
            const [offset, setOffset] = useState(0);
            const uid = useId();
            const pathId = `curve-${uid}`;
            const pathD = `M-100,40 Q500,${40 + curveAmount} 1540,40`;

            const dragRef = useRef(false);
            const lastXRef = useRef(0);
            const dirRef = useRef(direction);
            const velRef = useRef(0);

            const textLength = spacing;
            const totalText = textLength
                ? Array(Math.ceil(1800 / textLength) + 2).fill(text).join('')
                : text;
            const ready = spacing > 0;

            useEffect(() => {
                if (measureRef.current) setSpacing(measureRef.current.getComputedTextLength());
            }, [text, className]);

            useEffect(() => {
                if (!spacing) return;
                if (textPathRef.current) {
                    const initial = -spacing;
                    textPathRef.current.setAttribute('startOffset', initial + 'px');
                    setOffset(initial);
                }
            }, [spacing]);

            useEffect(() => {
                if (!spacing || !ready) return;
                let frame = 0;
                const step = () => {
                    if (!dragRef.current && textPathRef.current) {
                        const delta = dirRef.current === 'right' ? speed : -speed;
                        const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');
                        let newOffset = currentOffset + delta;

                        const wrapPoint = spacing;
                        if (newOffset <= -wrapPoint) newOffset += wrapPoint;
                        if (newOffset > 0) newOffset -= wrapPoint;

                        textPathRef.current.setAttribute('startOffset', newOffset + 'px');
                        setOffset(newOffset);
                    }
                    frame = requestAnimationFrame(step);
                };
                frame = requestAnimationFrame(step);
                return () => cancelAnimationFrame(frame);
            }, [spacing, speed, ready]);

            const onPointerDown = e => {
                if (!interactive) return;
                dragRef.current = true;
                lastXRef.current = e.clientX;
                velRef.current = 0;
                e.target.setPointerCapture(e.pointerId);
            };

            const onPointerMove = e => {
                if (!interactive || !dragRef.current || !textPathRef.current) return;
                const dx = e.clientX - lastXRef.current;
                lastXRef.current = e.clientX;
                velRef.current = dx;

                const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');
                let newOffset = currentOffset + dx;

                const wrapPoint = spacing;
                if (newOffset <= -wrapPoint) newOffset += wrapPoint;
                if (newOffset > 0) newOffset -= wrapPoint;

                textPathRef.current.setAttribute('startOffset', newOffset + 'px');
                setOffset(newOffset);
            };

            const endDrag = () => {
                if (!interactive) return;
                dragRef.current = false;
                dirRef.current = velRef.current > 0 ? 'right' : 'left';
            };

            const cursorStyle = interactive ? 'grab' : 'auto';

            return (
                <div
                    className="curved-loop-jacket"
                    style={{ visibility: ready ? 'visible' : 'hidden', cursor: cursorStyle }}
                    onPointerDown={onPointerDown}
                    onPointerMove={onPointerMove}
                    onPointerUp={endDrag}
                    onPointerLeave={endDrag}
                >
                    <svg className="curved-loop-svg" viewBox="0 0 1440 120">
                        <text ref={measureRef} xmlSpace="preserve" style={{ visibility: 'hidden', opacity: 0, pointerEvents: 'none' }}>
                            {text}
                        </text>
                        <defs>
                            <path ref={pathRef} id={pathId} d={pathD} fill="none" stroke="transparent" />
                        </defs>
                        {ready && (
                            <text fontWeight="bold" xmlSpace="preserve" className={className}>
                                <textPath ref={textPathRef} href={`#${pathId}`} startOffset={offset + 'px'} xmlSpace="preserve">
                                    {totalText}
                                </textPath>
                            </text>
                        )}
                    </svg>
                </div>
            );
        };

        // Render both effects
        const App = () => (
            <>
                <Crosshair color="var(--accent-color)" />
                <ClickSpark sparkColor="var(--accent-secondary)" sparkSize={25} sparkRadius={40} sparkCount={12} duration={500} />
            </>
        );

        ReactDOM.createRoot(document.getElementById('crosshair-root')).render(<App />);

        // Render CurvedLoop title
        ReactDOM.createRoot(document.getElementById('curved-title-root')).render(
            <CurvedLoop
                marqueeText="✦ Projetos ✦ Projetos ✦ Projetos "
                speed={1.5}
                curveAmount={150}
                direction="left"
                interactive
            />
        );

        // GridDistortion Component with Three.js
        const GridDistortion = ({ grid = 15, mouse = 0.1, strength = 0.15, relaxation = 0.9, imageSrc }) => {
            const containerRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;
                const container = containerRef.current;

                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000000, 0);
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);
                camera.position.z = 2;

                const vertexShader = `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const fragmentShader = `
                    uniform sampler2D uDataTexture;
                    uniform sampler2D uTexture;
                    varying vec2 vUv;
                    void main() {
                        vec2 uv = vUv;
                        vec4 offset = texture2D(uDataTexture, vUv);
                        vec4 color = texture2D(uTexture, uv - 0.02 * offset.rg);
                        // Convert to grayscale
                        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        gl_FragColor = vec4(vec3(gray), color.a);
                    }
                `;

                const uniforms = {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector4() },
                    uTexture: { value: null },
                    uDataTexture: { value: null }
                };

                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageSrc, texture => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    uniforms.uTexture.value = texture;
                    handleResize();
                });

                const size = grid;
                const data = new Float32Array(4 * size * size);
                for (let i = 0; i < size * size; i++) {
                    data[i * 4] = Math.random() * 255 - 125;
                    data[i * 4 + 1] = Math.random() * 255 - 125;
                }

                const dataTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
                dataTexture.needsUpdate = true;
                uniforms.uDataTexture.value = dataTexture;

                const material = new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms,
                    vertexShader,
                    fragmentShader,
                    transparent: true
                });

                const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);
                const plane = new THREE.Mesh(geometry, material);
                scene.add(plane);

                const handleResize = () => {
                    const rect = container.getBoundingClientRect();
                    const width = rect.width;
                    const height = rect.height;
                    if (width === 0 || height === 0) return;

                    renderer.setSize(width, height);
                    const containerAspect = width / height;
                    plane.scale.set(containerAspect, 1, 1);

                    const frustumHeight = 1;
                    const frustumWidth = frustumHeight * containerAspect;
                    camera.left = -frustumWidth / 2;
                    camera.right = frustumWidth / 2;
                    camera.top = frustumHeight / 2;
                    camera.bottom = -frustumHeight / 2;
                    camera.updateProjectionMatrix();
                    uniforms.resolution.value.set(width, height, 1, 1);
                };

                window.addEventListener('resize', handleResize);

                const mouseState = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 };

                const handleMouseMove = e => {
                    const rect = container.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width;
                    const y = 1 - (e.clientY - rect.top) / rect.height;
                    mouseState.vX = x - mouseState.prevX;
                    mouseState.vY = y - mouseState.prevY;
                    Object.assign(mouseState, { x, y, prevX: x, prevY: y });
                };

                container.addEventListener('mousemove', handleMouseMove);
                handleResize();

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    uniforms.time.value += 0.05;

                    const data = dataTexture.image.data;
                    for (let i = 0; i < size * size; i++) {
                        data[i * 4] *= relaxation;
                        data[i * 4 + 1] *= relaxation;
                    }

                    const gridMouseX = size * mouseState.x;
                    const gridMouseY = size * mouseState.y;
                    const maxDist = size * mouse;

                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const distSq = Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);
                            if (distSq < maxDist * maxDist) {
                                const index = 4 * (i + size * j);
                                const power = Math.min(maxDist / Math.sqrt(distSq), 10);
                                data[index] += strength * 100 * mouseState.vX * power;
                                data[index + 1] -= strength * 100 * mouseState.vY * power;
                            }
                        }
                    }

                    dataTexture.needsUpdate = true;
                    renderer.render(scene, camera);
                };

                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    container.removeEventListener('mousemove', handleMouseMove);
                    renderer.dispose();
                    geometry.dispose();
                    material.dispose();
                    dataTexture.dispose();
                };
            }, [grid, mouse, strength, relaxation, imageSrc]);

            return (
                <div
                    ref={containerRef}
                    className="distortion-container"
                />
            );
        };

        // GridDistortion Slideshow for header
        const GridDistortionSlideshow = () => {
            // Using the same images as defined in script.js projects array
            const images = [
                'project_1.png',
                'project_2.png',
                'project_3.png'
            ];
            const [currentIndex, setCurrentIndex] = useState(0);
            const [rotation, setRotation] = useState(() => (Math.random() * 16) - 8);
            const [isGlitching, setIsGlitching] = useState(false);

            useEffect(() => {
                const interval = setInterval(() => {
                    // 1. Start Glitch on old image
                    setIsGlitching(true);

                    // 2. Change image and rotation after 300ms (effect bridges the swap)
                    setTimeout(() => {
                        setCurrentIndex(prev => (prev + 1) % images.length);
                        setRotation((Math.random() * 16) - 8);
                    }, 300);

                    // 3. Stop glitch after total 800ms
                    setTimeout(() => setIsGlitching(false), 800);
                }, 3000);
                return () => clearInterval(interval);
            }, []);

            return (
                <div
                    className={isGlitching ? 'glitch-container glitch-active' : 'glitch-container'}
                    style={{
                        height: '70%',
                        aspectRatio: '1 / 1',
                        transform: `rotate(${rotation}deg)`,
                        transition: 'transform 0.1s ease-out'
                    }}
                >
                    <img
                        src={images[currentIndex]}
                        alt="Project"
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'cover',
                            filter: 'grayscale(100%)'
                        }}
                    />
                </div>
            );
        };

        // Render GridDistortion slideshow in header
        // Preloader Logic using Framer Motion
        const { motion, useSpring, useTransform } = window.Motion;

        const STRIP_CHARS = "abcdefghijklmnopqrstuvwxyz0123456789."; // Added dot 
        const REPEATED_STRIP = STRIP_CHARS.repeat(4);

        function CharacterStrip({ targetChar, height, duration, delay }) {
            const baseIndex = STRIP_CHARS.indexOf(targetChar.toLowerCase());
            // Target is in the last set (3rd index 2) to ensure long scroll
            const targetIndex = baseIndex + (STRIP_CHARS.length * 3);

            // Start at a random position in the first set
            const startIndex = Math.floor(Math.random() * STRIP_CHARS.length);

            // Faster spring physics for ~1s settling time
            const springValue = useSpring(startIndex, { stiffness: 120, damping: 20 });

            useEffect(() => {
                const timeout = setTimeout(() => {
                    springValue.set(targetIndex);
                }, delay);
                return () => clearTimeout(timeout);
            }, [targetIndex, delay]);

            const y = useTransform(springValue, (latest) => -latest * height);

            return (
                <div style={{ height: height, overflow: 'hidden', position: 'relative' }}>
                    <motion.div style={{ y, display: 'flex', flexDirection: 'column' }}>
                        {REPEATED_STRIP.split('').map((char, i) => (
                            <div key={i} className="counter-number" style={{ height: height, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                {char}
                            </div>
                        ))}
                    </motion.div>
                </div>
            );
        }

        const Preloader = () => {
            const [visible, setVisible] = useState(true);
            const targetText = "madebygabs.";
            // Adjust font size since text is longer now
            const fontSize = window.innerWidth < 600 ? window.innerWidth * 0.12 : window.innerWidth * 0.08;
            const height = fontSize * 1.1;

            useEffect(() => {
                // Reveal ~1.5s. Hold ~1s. Total 2.5s.
                const timer = setTimeout(() => {
                    setVisible(false);
                }, 2500);
                return () => clearTimeout(timer);
            }, []);

            // Switching to Fade Out + Scale Up animation
            return (
                <motion.div
                    className="preloader-overlay"
                    initial={{ opacity: 1, scale: 1 }}
                    animate={{
                        opacity: visible ? 1 : 0,
                        scale: visible ? 1 : 1.1,
                        pointerEvents: visible ? 'auto' : 'none'
                    }}
                    transition={{ duration: 0.8, ease: "easeInOut" }}
                >
                    <div style={{
                        display: 'flex',
                        gap: '0.05em',
                        fontFamily: 'var(--font-heading)',
                        fontWeight: 900,
                        fontSize: fontSize,
                        color: 'var(--bg-color)', // Inverted color as requested
                        height: height,
                        overflow: 'hidden',
                        lineHeight: 1
                    }}>
                        {targetText.split('').map((char, i) => (
                            <CharacterStrip
                                key={i}
                                targetChar={char}
                                height={height}
                                delay={100 + i * 80} // Faster stagger: 100ms start + 80ms per char
                                duration={1000} // Unused but kept for reference
                            />
                        ))}
                    </div>
                </motion.div>
            );
        };

        ReactDOM.createRoot(document.getElementById('preloader-root')).render(<Preloader />);

        // Render GridDistortion slideshow in header
        ReactDOM.createRoot(document.getElementById('grid-distortion-root')).render(
            <GridDistortionSlideshow />
        );

        // Theme Management
        const getThemeColors = (theme) => {
            if (theme === 'theme2') {
                return {
                    bg: [0.004, 0.651, 0.424], // #01a66c Green
                    wave: [0.0, 0.0, 0.0]      // Black Wave
                };
            }
            // Default Theme 1 (Risograph)
            return {
                bg: [0.957, 0.906, 0.831], // #F4E7D4 Cream
                wave: [0.0, 0.0, 0.0]      // Black Wave
            };
        };

        const ThemeSwitcher = () => {
            const [currentTheme, setCurrentTheme] = useState('theme1');

            const setTheme = (theme) => {
                setCurrentTheme(theme);
                document.documentElement.setAttribute('data-theme', theme);

                window.dispatchEvent(new CustomEvent('theme-change', {
                    detail: { theme }
                }));
            };

            return (
                <div style={{
                    position: 'fixed',
                    top: '2rem',
                    right: '2rem',
                    zIndex: 9999,
                    display: 'flex',
                    gap: '12px'
                }}>
                    {/* Theme 1: Cream */}
                    <button
                        onClick={() => setTheme('theme1')}
                        aria-label="Theme 1"
                        style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '50%',
                            background: '#F4E7D4',
                            border: currentTheme === 'theme1' ? '3px solid #ed2d92' : '1px solid rgba(0,0,0,0.1)',
                            cursor: 'pointer',
                            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                            transition: 'transform 0.2s',
                            transform: currentTheme === 'theme1' ? 'scale(1.1)' : 'scale(1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 'bold',
                            color: '#000000',
                            fontSize: '14px'
                        }}
                    >1</button>
                    {/* Theme 2: Green */}
                    <button
                        onClick={() => setTheme('theme2')}
                        aria-label="Theme 2"
                        style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '50%',
                            background: '#01a66c',
                            border: currentTheme === 'theme2' ? '3px solid #ed2d92' : '1px solid rgba(0,0,0,0.1)',
                            cursor: 'pointer',
                            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                            transition: 'transform 0.2s',
                            transform: currentTheme === 'theme2' ? 'scale(1.1)' : 'scale(1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 'bold',
                            color: '#ffffff',
                            fontSize: '14px'
                        }}
                    >2</button>
                </div>
            );
        };

        // Dither Background Effect Component
        const DitherBackground = ({
            waveSpeed = 0.05,
            waveFrequency = 3,
            waveAmplitude = 0.3,
            colorNum = 4,
            pixelSize = 2,
            enableMouseInteraction = true,
            mouseRadius = 0.3
        }) => {
            const containerRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;
                const container = containerRef.current;

                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const fragmentShader = `
                    precision highp float;
                    uniform vec2 resolution;
                    uniform float time;
                    uniform float waveSpeed;
                    uniform float waveFrequency;
                    uniform float waveAmplitude;
                    uniform vec3 waveColor;
                    uniform vec3 backgroundColor;
                    uniform vec2 mousePos;
                    uniform int enableMouseInteraction;
                    uniform float mouseRadius;
                    uniform float colorNum;
                    uniform float pixelSize;

                    vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                    vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

                    float cnoise(vec2 P) {
                        vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);
                        vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);
                        Pi = mod289(Pi);
                        vec4 ix = Pi.xzxz, iy = Pi.yyww;
                        vec4 fx = Pf.xzxz, fy = Pf.yyww;
                        vec4 i = permute(permute(ix) + iy);
                        vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;
                        vec4 gy = abs(gx) - 0.5;
                        vec4 tx = floor(gx + 0.5);
                        gx = gx - tx;
                        vec2 g00 = vec2(gx.x, gy.x), g10 = vec2(gx.y, gy.y);
                        vec2 g01 = vec2(gx.z, gy.z), g11 = vec2(gx.w, gy.w);
                        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11));
                        g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;
                        float n00 = dot(g00, vec2(fx.x, fy.x)), n10 = dot(g10, vec2(fx.y, fy.y));
                        float n01 = dot(g01, vec2(fx.z, fy.z)), n11 = dot(g11, vec2(fx.w, fy.w));
                        vec2 fade_xy = fade(Pf.xy);
                        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                        return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);
                    }

                    float fbm(vec2 p) {
                        float value = 0.0, amp = 1.0, freq = waveFrequency;
                        for (int i = 0; i < 4; i++) {
                            value += amp * abs(cnoise(p));
                            p *= freq;
                            amp *= waveAmplitude;
                        }
                        return value;
                    }

                    float pattern(vec2 p) {
                        vec2 p2 = p - time * waveSpeed;
                        return fbm(p + fbm(p2));
                    }

                    // Bayer 8x8 dithering
                    float bayer8(vec2 pos) {
                        ivec2 p = ivec2(mod(pos, 8.0));
                        int index = p.x + p.y * 8;
                        float matrix[64];
                        matrix[0]=0.0; matrix[1]=48.0; matrix[2]=12.0; matrix[3]=60.0; matrix[4]=3.0; matrix[5]=51.0; matrix[6]=15.0; matrix[7]=63.0;
                        matrix[8]=32.0; matrix[9]=16.0; matrix[10]=44.0; matrix[11]=28.0; matrix[12]=35.0; matrix[13]=19.0; matrix[14]=47.0; matrix[15]=31.0;
                        matrix[16]=8.0; matrix[17]=56.0; matrix[18]=4.0; matrix[19]=52.0; matrix[20]=11.0; matrix[21]=59.0; matrix[22]=7.0; matrix[23]=55.0;
                        matrix[24]=40.0; matrix[25]=24.0; matrix[26]=36.0; matrix[27]=20.0; matrix[28]=43.0; matrix[29]=27.0; matrix[30]=39.0; matrix[31]=23.0;
                        matrix[32]=2.0; matrix[33]=50.0; matrix[34]=14.0; matrix[35]=62.0; matrix[36]=1.0; matrix[37]=49.0; matrix[38]=13.0; matrix[39]=61.0;
                        matrix[40]=34.0; matrix[41]=18.0; matrix[42]=46.0; matrix[43]=30.0; matrix[44]=33.0; matrix[45]=17.0; matrix[46]=45.0; matrix[47]=29.0;
                        matrix[48]=10.0; matrix[49]=58.0; matrix[50]=6.0; matrix[51]=54.0; matrix[52]=9.0; matrix[53]=57.0; matrix[54]=5.0; matrix[55]=53.0;
                        matrix[56]=42.0; matrix[57]=26.0; matrix[58]=38.0; matrix[59]=22.0; matrix[60]=41.0; matrix[61]=25.0; matrix[62]=37.0; matrix[63]=21.0;
                        return matrix[index] / 64.0;
                    }

                    vec3 dither(vec3 color, vec2 fragCoord, float pSize) {
                        vec2 scaledCoord = floor(fragCoord / pSize);
                        float threshold = bayer8(scaledCoord) - 0.25;
                        float step = 1.0 / (colorNum - 1.0);
                        color += threshold * step;
                        color = clamp(color - 0.2, 0.0, 1.0);
                        return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
                    }

                    void main() {
                        vec2 uv = gl_FragCoord.xy / resolution.xy;
                        vec2 uvOriginal = uv;
                        uv -= 0.5;
                        uv.x *= resolution.x / resolution.y;
                        float f = pattern(uv);
                        
                        if (enableMouseInteraction == 1) {
                            vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);
                            mouseNDC.x *= resolution.x / resolution.y;
                            float dist = length(uv - mouseNDC);
                            float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);
                            // Push effect away from mouse - reduce pattern intensity
                            f *= (1.0 - effect * 0.8);
                        }
                        
                        // Mix background color with wave color
                        vec3 col = mix(backgroundColor, waveColor, f);
                        col = dither(col, gl_FragCoord.xy, pixelSize);
                        
                        // Vertical gradient fade - toward background color
                        float fadeStart = 0.5;
                        float fadeEnd = 0.0;
                        // fadeFactor: 0.0 at bottom (full background), 1.0 at top (full dither)
                        float fadeFactor = smoothstep(fadeEnd, fadeStart, uvOriginal.y);
                        
                        // Mix final color with background color for the fade
                        col = mix(backgroundColor, col, fadeFactor);
                        
                        gl_FragColor = vec4(col, 1.0);
                    }
                `;

                // Initial colors based on default Theme 1
                const initialColors = getThemeColors('theme1');
                const uniforms = {
                    resolution: { value: new THREE.Vector2() },
                    time: { value: 0 },
                    waveSpeed: { value: waveSpeed },
                    waveFrequency: { value: waveFrequency },
                    waveAmplitude: { value: waveAmplitude },
                    waveColor: { value: new THREE.Vector3(...initialColors.wave) },
                    backgroundColor: { value: new THREE.Vector3(...initialColors.bg) },
                    mousePos: { value: new THREE.Vector2() },
                    enableMouseInteraction: { value: enableMouseInteraction ? 1 : 0 },
                    mouseRadius: { value: mouseRadius },
                    colorNum: { value: colorNum },
                    pixelSize: { value: pixelSize }
                };

                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                const handleResize = () => {
                    const rect = container.getBoundingClientRect();
                    renderer.setSize(rect.width, rect.height);
                    uniforms.resolution.value.set(rect.width * renderer.getPixelRatio(), rect.height * renderer.getPixelRatio());
                };

                window.addEventListener('resize', handleResize);
                handleResize();

                const handleMouseMove = e => {
                    const rect = container.getBoundingClientRect();
                    const dpr = renderer.getPixelRatio();
                    uniforms.mousePos.value.set((e.clientX - rect.left) * dpr, (e.clientY - rect.top) * dpr);
                };

                window.addEventListener('mousemove', handleMouseMove);

                // Listen for theme changes to update uniforms
                const handleThemeChange = (e) => {
                    const newColors = getThemeColors(e.detail.theme);
                    uniforms.backgroundColor.value.set(...newColors.bg);
                    uniforms.waveColor.value.set(...newColors.wave);
                };
                window.addEventListener('theme-change', handleThemeChange);

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    uniforms.time.value += 0.016;
                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('theme-change', handleThemeChange);
                    renderer.dispose();
                    geometry.dispose();
                    material.dispose();
                };
            }, [waveSpeed, waveFrequency, waveAmplitude, colorNum, pixelSize, enableMouseInteraction, mouseRadius]);

            return <div ref={containerRef} className="dither-container" />;
        };

        // Render Theme Switcher
        const themeRoot = document.createElement('div');
        document.body.appendChild(themeRoot);
        ReactDOM.createRoot(themeRoot).render(<ThemeSwitcher />); // Render Dither background
        ReactDOM.createRoot(document.getElementById('dither-bg-root')).render(
            <DitherBackground
                waveSpeed={0.05}
                waveFrequency={3}
                waveAmplitude={0.3}
                colorNum={4}
                pixelSize={4}
                enableMouseInteraction={true}
                mouseRadius={0.3}
            />
        );
    </script>

    <script src="script.js"></script>
</body>

</html>