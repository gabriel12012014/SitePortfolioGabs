<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio | Gabriel</title>

    <!-- SEO -->
    <meta name="description" content="Portfolio de Gabriel - Design, Ilustração, Desenvolvimento Web e Games">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Outfit:wght@400;600;700;800&display=swap"
        rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">

    <!-- Theme Persistence Prep -->
    <script>
        (function () {
            const savedTheme = localStorage.getItem('site-theme') || 'theme1';
            document.documentElement.setAttribute('data-theme', savedTheme);
        })();
    </script>
</head>

<body>
    <div id="preloader-root"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 99999; background: var(--accent-color);">
    </div>
    <div class="global-grain"></div>
    <header class="hero-header">
        <!-- Site Logo -->
        <div class="site-logo header-entrance">madebygabs.</div>
        <!-- Dither Background Effect -->
        <div id="dither-bg-root"></div>
        <!-- GridDistortion Slideshow -->
        <div id="grid-distortion-root" class="header-entrance"></div>



        <nav class="main-nav header-entrance">
            <div id="dock-root"></div>
        </nav>


    </header>

    <section id="work" class="work-section">
        <!-- CurvedLoop Title - Full Width -->
        <div id="curved-title-root"></div>

        <div class="container">

            <div class="filter-buttons">
                <button class="filter-btn active" data-filter="all">Todos</button>
                <button class="filter-btn" data-filter="Design">Design</button>
                <button class="filter-btn" data-filter="Ilustração">Ilustração</button>
                <button class="filter-btn" data-filter="Game Dev">Games</button>
            </div>

            <div class="project-grid" id="project-grid">
                <!-- Projects will be rendered here by JS -->
            </div>
    </section>

    <section id="contact" class="contact-section">
        <div class="contact-container">
            <h2 class="contact-title">Manda um zap!</h2>
            <div class="contact-links-row">
                <a href="mailto:gabriel12012014@outlook.com" class="contact-link">
                    <svg class="contact-icon" viewBox="0 0 24 24" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" />
                    </svg>
                    gabriel12012014@outlook.com
                </a>
                <a href="https://wa.me/5511991878100" target="_blank" class="contact-link">
                    <svg class="contact-icon" viewBox="0 0 24 24" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z" />
                    </svg>
                    11 99187-8100
                </a>
                <a href="https://instagram.com/gabaszw" target="_blank" class="contact-link">
                    <svg class="contact-icon" viewBox="0 0 24 24" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z" />
                    </svg>
                    @gabaszw
                </a>
                <a href="https://putsgabs.itch.io/" target="_blank" class="contact-link">
                    <svg class="contact-icon" viewBox="0 0 245.371 220.736" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M31.99 1.365C21.287 7.72.2 31.945 0 38.298v10.516C0 62.144 12.46 73.86 23.773 73.86c13.584 0 24.902-11.258 24.903-24.62 0 13.362 10.93 24.62 24.515 24.62 13.586 0 24.165-11.258 24.165-24.62 0 13.362 11.622 24.62 25.207 24.62h.246c13.586 0 25.208-11.258 25.208-24.62 0 13.362 10.58 24.62 24.164 24.62 13.585 0 24.515-11.258 24.515-24.62 0 13.362 11.32 24.62 24.903 24.62 11.313 0 23.773-11.714 23.773-25.046V38.298c-.2-6.354-21.287-30.58-31.988-36.933C180.118.197 157.056-.005 122.685 0c-34.37.003-81.228.54-90.697 1.365zm65.194 66.217a28.025 28.025 0 0 1-4.78 6.155c-5.128 5.014-12.157 8.122-19.906 8.122a28.482 28.482 0 0 1-19.948-8.126c-1.858-1.82-3.27-3.766-4.563-6.032l-.006.004c-1.292 2.27-3.092 4.215-4.954 6.037a28.5 28.5 0 0 1-19.948 8.12c-.934 0-1.906-.258-2.692-.528-1.092 11.372-1.553 22.24-1.716 30.164l-.002.045c-.02 4.024-.04 7.333-.06 11.93.21 23.86-2.363 77.334 10.52 90.473 19.964 4.655 56.7 6.775 93.555 6.788h.006c36.854-.013 73.59-2.133 93.554-6.788 12.883-13.14 10.31-66.614 10.52-90.474-.022-4.596-.04-7.905-.06-11.93l-.003-.045c-.162-7.926-.623-18.793-1.715-30.165-.786.27-1.757.528-2.692.528a28.5 28.5 0 0 1-19.948-8.12c-1.862-1.822-3.662-3.766-4.955-6.037l-.006-.004c-1.294 2.266-2.705 4.213-4.563 6.032a28.48 28.48 0 0 1-19.947 8.125c-7.748 0-14.778-3.11-19.906-8.123a28.025 28.025 0 0 1-4.78-6.155 27.99 27.99 0 0 1-4.736 6.155 28.49 28.49 0 0 1-19.95 8.124c-.27 0-.54-.012-.81-.02h-.007c-.27.008-.54.02-.813.02a28.49 28.49 0 0 1-19.95-8.123 27.992 27.992 0 0 1-4.736-6.155zm-20.486 26.49l-.002.01h.015c8.113.017 15.32 0 24.25 9.746 7.028-.737 14.372-1.105 21.722-1.094h.006c7.35-.01 14.694.357 21.723 1.094 8.93-9.747 16.137-9.73 24.25-9.746h.014l-.002-.01c3.833 0 19.166 0 29.85 30.007L210 165.244c8.504 30.624-2.723 31.373-16.727 31.4-20.768-.773-32.267-15.855-32.267-30.935-11.496 1.884-24.907 2.826-38.318 2.827h-.006c-13.412 0-26.823-.943-38.318-2.827 0 15.08-11.5 30.162-32.267 30.935-14.004-.027-25.23-.775-16.726-31.4L46.85 124.08C57.534 94.073 72.867 94.073 76.7 94.073zm45.985 23.582v.006c-.02.02-21.863 20.08-25.79 27.215l14.304-.573v12.474c0 .584 5.74.346 11.486.08h.006c5.744.266 11.485.504 11.485-.08v-12.474l14.304.573c-3.928-7.135-25.79-27.215-25.79-27.215v-.006l-.003.002z" />
                    </svg>
                    itch.io
                </a>
            </div>
        </div>

        <div class="massive-footer-text">madebygabs.</div>

        <div class="contact-container">
            <div class="footer-row">
                <div class="location-text">São Paulo (SP) - Brasil</div>
                <div class="attribution-text">Site feito usando a ferramenta Antigravity</div>
            </div>
        </div>
    </section>



    <!-- Crosshair Effect Root -->
    <div id="crosshair-root"></div>

    <!-- React, Babel, GSAP and Three.js CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- Crosshair Component (Babel) -->
    <script type="text/babel">
        const { useRef, useEffect, useState, useId, Children, cloneElement, useMemo } = React;
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        const getMousePos = (e, container) => {
            if (container) {
                const bounds = container.getBoundingClientRect();
                return { x: e.clientX - bounds.left, y: e.clientY - bounds.top };
            }
            return { x: e.clientX, y: e.clientY };
        };

        const Crosshair = ({ color = '#ff69b4', containerRef = null }) => {
            const cursorRef = useRef(null);
            const lineHorizontalRef = useRef(null);
            const lineVerticalRef = useRef(null);
            const filterXRef = useRef(null);
            const filterYRef = useRef(null);

            let mouse = { x: 0, y: 0 };

            useEffect(() => {
                const handleMouseMove = ev => {
                    mouse = getMousePos(ev, containerRef?.current);
                    if (containerRef?.current) {
                        const bounds = containerRef.current.getBoundingClientRect();
                        if (
                            ev.clientX < bounds.left ||
                            ev.clientX > bounds.right ||
                            ev.clientY < bounds.top ||
                            ev.clientY > bounds.bottom
                        ) {
                            gsap.to([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0 });
                        } else {
                            gsap.to([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0.4 });
                        }
                    }
                };

                const target = containerRef?.current || window;
                target.addEventListener('mousemove', handleMouseMove);

                const renderedStyles = {
                    tx: { previous: 0, current: 0, amt: 0.15 },
                    ty: { previous: 0, current: 0, amt: 0.15 }
                };

                gsap.set([lineHorizontalRef.current, lineVerticalRef.current], { opacity: 0 });

                const onMouseMove = () => {
                    renderedStyles.tx.previous = renderedStyles.tx.current = mouse.x;
                    renderedStyles.ty.previous = renderedStyles.ty.current = mouse.y;
                    gsap.to([lineHorizontalRef.current, lineVerticalRef.current], {
                        duration: 0.9,
                        ease: 'Power3.easeOut',
                        opacity: 0.4
                    });
                    requestAnimationFrame(render);
                    target.removeEventListener('mousemove', onMouseMove);
                };

                target.addEventListener('mousemove', onMouseMove);

                const primitiveValues = { turbulence: 0 };
                const tl = gsap.timeline({
                    paused: true,
                    onStart: () => {
                        lineHorizontalRef.current.style.filter = `url(#filter-noise-x)`;
                        lineVerticalRef.current.style.filter = `url(#filter-noise-y)`;
                    },
                    onUpdate: () => {
                        if (filterXRef.current && filterYRef.current) {
                            filterXRef.current.setAttribute('baseFrequency', primitiveValues.turbulence);
                            filterYRef.current.setAttribute('baseFrequency', primitiveValues.turbulence);
                        }
                    },
                    onComplete: () => {
                        if (lineHorizontalRef.current && lineVerticalRef.current) {
                            lineHorizontalRef.current.style.filter = lineVerticalRef.current.style.filter = 'none';
                        }
                    }
                })
                    .to(primitiveValues, {
                        duration: 0.5,
                        ease: 'power1',
                        startAt: { turbulence: 1 },
                        turbulence: 0
                    });

                const enter = () => tl.restart();
                const leave = () => tl.progress(1).kill();

                const render = () => {
                    renderedStyles.tx.current = mouse.x;
                    renderedStyles.ty.current = mouse.y;
                    for (const key in renderedStyles) {
                        renderedStyles[key].previous = lerp(
                            renderedStyles[key].previous,
                            renderedStyles[key].current,
                            renderedStyles[key].amt
                        );
                    }
                    if (lineHorizontalRef.current && lineVerticalRef.current) {
                        gsap.set(lineVerticalRef.current, { x: renderedStyles.tx.previous });
                        gsap.set(lineHorizontalRef.current, { y: renderedStyles.ty.previous });
                    }
                    requestAnimationFrame(render);
                };

                const interactiveElements = containerRef?.current ? containerRef.current.querySelectorAll('a, button, .dock-item, [onclick], [role="button"], input[type="button"], input[type="submit"], .filter-btn, .project-card') : document.querySelectorAll('a, button, .dock-item, [onclick], [role="button"], input[type="button"], input[type="submit"], .filter-btn, .project-card');
                interactiveElements.forEach(element => {
                    element.addEventListener('mouseenter', enter);
                    element.addEventListener('mouseleave', leave);
                });

                return () => {
                    target.removeEventListener('mousemove', handleMouseMove);
                    target.removeEventListener('mousemove', onMouseMove);
                    interactiveElements.forEach(element => {
                        element.removeEventListener('mouseenter', enter);
                        element.removeEventListener('mouseleave', leave);
                    });
                };
            }, [containerRef]);

            return (
                <div
                    ref={cursorRef}
                    className="cursor"
                    style={{
                        position: containerRef ? 'absolute' : 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10000
                    }}
                >
                    <svg style={{ position: 'absolute', left: 0, top: 0, width: '100%', height: '100%' }}>
                        <defs>
                            <filter id="filter-noise-x">
                                <feTurbulence type="fractalNoise" baseFrequency="0.000001" numOctaves="1" ref={filterXRef} />
                                <feDisplacementMap in="SourceGraphic" scale="40" />
                            </filter>
                            <filter id="filter-noise-y">
                                <feTurbulence type="fractalNoise" baseFrequency="0.000001" numOctaves="1" ref={filterYRef} />
                                <feDisplacementMap in="SourceGraphic" scale="40" />
                            </filter>
                        </defs>
                    </svg>
                    <div
                        ref={lineHorizontalRef}
                        style={{
                            position: 'absolute',
                            width: '100%',
                            height: '3px',
                            background: `linear-gradient(to right, transparent, ${color} 15%, ${color} 85%, transparent)`,
                            pointerEvents: 'none',
                            transform: 'translateY(50%)',
                            opacity: 0
                        }}
                    ></div>
                    <div
                        ref={lineVerticalRef}
                        style={{
                            position: 'absolute',
                            height: '100%',
                            width: '3px',
                            background: `linear-gradient(to bottom, transparent, ${color} 15%, ${color} 85%, transparent)`,
                            pointerEvents: 'none',
                            transform: 'translateX(50%)',
                            opacity: 0
                        }}
                    ></div>
                </div>
            );
        };

        // ClickSpark Component
        const ClickSpark = ({
            sparkColor = '#ff69b4',
            sparkSize = 10,
            sparkRadius = 15,
            sparkCount = 8,
            duration = 400,
            easing = 'ease-out',
            extraScale = 1.0
        }) => {
            const canvasRef = useRef(null);
            const sparksRef = useRef([]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                return () => window.removeEventListener('resize', resizeCanvas);
            }, []);

            const easeFunc = (t) => {
                switch (easing) {
                    case 'linear': return t;
                    case 'ease-in': return t * t;
                    case 'ease-in-out': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    default: return t * (2 - t);
                }
            };

            const [resolvedColor, setResolvedColor] = useState(sparkColor);

            useEffect(() => {
                const updateColor = () => {
                    if (sparkColor.startsWith('var(')) {
                        const varName = sparkColor.match(/var\(([^)]+)\)/)[1];
                        setResolvedColor(getComputedStyle(document.documentElement).getPropertyValue(varName).trim());
                    } else {
                        setResolvedColor(sparkColor);
                    }
                };
                updateColor();
                window.addEventListener('theme-change', updateColor);
                return () => window.removeEventListener('theme-change', updateColor);
            }, [sparkColor]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                let animationId;

                const draw = (timestamp) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    sparksRef.current = sparksRef.current.filter(spark => {
                        const elapsed = timestamp - spark.startTime;
                        if (elapsed >= duration) return false;

                        const progress = elapsed / duration;
                        const eased = easeFunc(progress);

                        const distance = eased * sparkRadius * extraScale;
                        const lineLength = sparkSize * (1 - eased);

                        const x1 = spark.x + distance * Math.cos(spark.angle);
                        const y1 = spark.y + distance * Math.sin(spark.angle);
                        const x2 = spark.x + (distance + lineLength) * Math.cos(spark.angle);
                        const y2 = spark.y + (distance + lineLength) * Math.sin(spark.angle);

                        ctx.strokeStyle = resolvedColor;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();

                        return true;
                    });

                    animationId = requestAnimationFrame(draw);
                };

                animationId = requestAnimationFrame(draw);

                return () => cancelAnimationFrame(animationId);
            }, [resolvedColor, sparkSize, sparkRadius, sparkCount, duration, easing, extraScale]);

            useEffect(() => {
                const handleClick = (e) => {
                    const now = performance.now();
                    const newSparks = Array.from({ length: sparkCount }, (_, i) => ({
                        x: e.clientX,
                        y: e.clientY,
                        angle: (2 * Math.PI * i) / sparkCount,
                        startTime: now
                    }));
                    sparksRef.current.push(...newSparks);
                };

                window.addEventListener('click', handleClick);
                return () => window.removeEventListener('click', handleClick);
            }, [sparkCount]);

            return (
                <canvas
                    ref={canvasRef}
                    style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        pointerEvents: 'none',
                        zIndex: 10001
                    }}
                />
            );
        };

        // CurvedLoop Component
        const CurvedLoop = ({
            marqueeText = '',
            speed = 2,
            className,
            curveAmount = 400,
            direction = 'left',
            interactive = true
        }) => {
            const text = (() => {
                const hasTrailing = /\s|\u00A0$/.test(marqueeText);
                return (hasTrailing ? marqueeText.replace(/\s+$/, '') : marqueeText) + '\u00A0';
            })();

            const measureRef = useRef(null);
            const textPathRef = useRef(null);
            const pathRef = useRef(null);
            const [spacing, setSpacing] = useState(0);
            const [offset, setOffset] = useState(0);
            const uid = useId();
            const pathId = `curve-${uid}`;
            const pathD = `M-100,40 Q500,${40 + curveAmount} 1540,40`;

            const dragRef = useRef(false);
            const lastXRef = useRef(0);
            const dirRef = useRef(direction);
            const velRef = useRef(0);

            const textLength = spacing;
            const totalText = textLength
                ? Array(Math.ceil(1800 / textLength) + 2).fill(text).join('')
                : text;
            const ready = spacing > 0;

            useEffect(() => {
                if (measureRef.current) setSpacing(measureRef.current.getComputedTextLength());
            }, [text, className]);

            useEffect(() => {
                if (!spacing) return;
                if (textPathRef.current) {
                    const initial = -spacing;
                    textPathRef.current.setAttribute('startOffset', initial + 'px');
                    setOffset(initial);
                }
            }, [spacing]);

            useEffect(() => {
                if (!spacing || !ready) return;
                let frame = 0;
                const step = () => {
                    if (!dragRef.current && textPathRef.current) {
                        const delta = dirRef.current === 'right' ? speed : -speed;
                        const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');
                        let newOffset = currentOffset + delta;

                        const wrapPoint = spacing;
                        if (newOffset <= -wrapPoint) newOffset += wrapPoint;
                        if (newOffset > 0) newOffset -= wrapPoint;

                        textPathRef.current.setAttribute('startOffset', newOffset + 'px');
                        setOffset(newOffset);
                    }
                    frame = requestAnimationFrame(step);
                };
                frame = requestAnimationFrame(step);
                return () => cancelAnimationFrame(frame);
            }, [spacing, speed, ready]);

            const onPointerDown = e => {
                if (!interactive) return;
                dragRef.current = true;
                lastXRef.current = e.clientX;
                velRef.current = 0;
                e.target.setPointerCapture(e.pointerId);
            };

            const onPointerMove = e => {
                if (!interactive || !dragRef.current || !textPathRef.current) return;
                const dx = e.clientX - lastXRef.current;
                lastXRef.current = e.clientX;
                velRef.current = dx;

                const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');
                let newOffset = currentOffset + dx;

                const wrapPoint = spacing;
                if (newOffset <= -wrapPoint) newOffset += wrapPoint;
                if (newOffset > 0) newOffset -= wrapPoint;

                textPathRef.current.setAttribute('startOffset', newOffset + 'px');
                setOffset(newOffset);
            };

            const endDrag = () => {
                if (!interactive) return;
                dragRef.current = false;
                dirRef.current = velRef.current > 0 ? 'right' : 'left';
            };

            const cursorStyle = interactive ? 'grab' : 'auto';

            return (
                <div
                    className="curved-loop-jacket"
                    style={{ visibility: ready ? 'visible' : 'hidden', cursor: cursorStyle }}
                    onPointerDown={onPointerDown}
                    onPointerMove={onPointerMove}
                    onPointerUp={endDrag}
                    onPointerLeave={endDrag}
                >
                    <svg className="curved-loop-svg" viewBox="0 0 1440 120">
                        <text ref={measureRef} xmlSpace="preserve" style={{ visibility: 'hidden', opacity: 0, pointerEvents: 'none' }}>
                            {text}
                        </text>
                        <defs>
                            <path ref={pathRef} id={pathId} d={pathD} fill="none" stroke="transparent" />
                        </defs>
                        {ready && (
                            <text fontWeight="bold" xmlSpace="preserve" className={className}>
                                <textPath ref={textPathRef} href={`#${pathId}`} startOffset={offset + 'px'} xmlSpace="preserve">
                                    {totalText}
                                </textPath>
                            </text>
                        )}
                    </svg>
                </div>
            );
        };

        // Render both effects
        const App = () => (
            <>
                <Crosshair color="var(--accent-color)" />
                <ClickSpark sparkColor="var(--accent-secondary)" sparkSize={25} sparkRadius={40} sparkCount={12} duration={500} />
            </>
        );

        ReactDOM.createRoot(document.getElementById('crosshair-root')).render(<App />);

        // Render CurvedLoop title
        ReactDOM.createRoot(document.getElementById('curved-title-root')).render(
            <CurvedLoop
                marqueeText="✦ Projetos ✦ Projetos ✦ Projetos "
                speed={1.5}
                curveAmount={150}
                direction="left"
                interactive
            />
        );

        // GridDistortion Component with Three.js
        const GridDistortion = ({ grid = 15, mouse = 0.1, strength = 0.15, relaxation = 0.9, imageSrc }) => {
            const containerRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;
                const container = containerRef.current;

                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000000, 0);
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);
                camera.position.z = 2;

                const vertexShader = `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const fragmentShader = `
                    uniform sampler2D uDataTexture;
                    uniform sampler2D uTexture;
                    varying vec2 vUv;
                    void main() {
                        vec2 uv = vUv;
                        vec4 offset = texture2D(uDataTexture, vUv);
                        vec4 color = texture2D(uTexture, uv - 0.02 * offset.rg);
                        // Convert to grayscale
                        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        gl_FragColor = vec4(vec3(gray), color.a);
                    }
                `;

                const uniforms = {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector4() },
                    uTexture: { value: null },
                    uDataTexture: { value: null }
                };

                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageSrc, texture => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    uniforms.uTexture.value = texture;
                    handleResize();
                });

                const size = grid;
                const data = new Float32Array(4 * size * size);
                for (let i = 0; i < size * size; i++) {
                    data[i * 4] = Math.random() * 255 - 125;
                    data[i * 4 + 1] = Math.random() * 255 - 125;
                }

                const dataTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
                dataTexture.needsUpdate = true;
                uniforms.uDataTexture.value = dataTexture;

                const material = new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms,
                    vertexShader,
                    fragmentShader,
                    transparent: true
                });

                const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);
                const plane = new THREE.Mesh(geometry, material);
                scene.add(plane);

                const handleResize = () => {
                    const rect = container.getBoundingClientRect();
                    const width = rect.width;
                    const height = rect.height;
                    if (width === 0 || height === 0) return;

                    renderer.setSize(width, height);
                    const containerAspect = width / height;
                    plane.scale.set(containerAspect, 1, 1);

                    const frustumHeight = 1;
                    const frustumWidth = frustumHeight * containerAspect;
                    camera.left = -frustumWidth / 2;
                    camera.right = frustumWidth / 2;
                    camera.top = frustumHeight / 2;
                    camera.bottom = -frustumHeight / 2;
                    camera.updateProjectionMatrix();
                    uniforms.resolution.value.set(width, height, 1, 1);
                };

                window.addEventListener('resize', handleResize);

                const mouseState = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 };

                const handleMouseMove = e => {
                    const rect = container.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width;
                    const y = 1 - (e.clientY - rect.top) / rect.height;
                    mouseState.vX = x - mouseState.prevX;
                    mouseState.vY = y - mouseState.prevY;
                    Object.assign(mouseState, { x, y, prevX: x, prevY: y });
                };

                container.addEventListener('mousemove', handleMouseMove);
                handleResize();

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    uniforms.time.value += 0.05;

                    const data = dataTexture.image.data;
                    for (let i = 0; i < size * size; i++) {
                        data[i * 4] *= relaxation;
                        data[i * 4 + 1] *= relaxation;
                    }

                    const gridMouseX = size * mouseState.x;
                    const gridMouseY = size * mouseState.y;
                    const maxDist = size * mouse;

                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const distSq = Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);
                            if (distSq < maxDist * maxDist) {
                                const index = 4 * (i + size * j);
                                const power = Math.min(maxDist / Math.sqrt(distSq), 10);
                                data[index] += strength * 100 * mouseState.vX * power;
                                data[index + 1] -= strength * 100 * mouseState.vY * power;
                            }
                        }
                    }

                    dataTexture.needsUpdate = true;
                    renderer.render(scene, camera);
                };

                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    container.removeEventListener('mousemove', handleMouseMove);
                    renderer.dispose();
                    geometry.dispose();
                    material.dispose();
                    dataTexture.dispose();
                };
            }, [grid, mouse, strength, relaxation, imageSrc]);

            return (
                <div
                    ref={containerRef}
                    className="distortion-container"
                />
            );
        };

        // GridDistortion Slideshow for header
        const GridDistortionSlideshow = () => {
            // Using the same images as defined in script.js projects array
            const images = [
                'project_1.png',
                'project_2.png',
                'project_3.png'
            ];
            const [currentIndex, setCurrentIndex] = useState(0);
            const [rotation, setRotation] = useState(() => (Math.random() * 16) - 8);
            const [isGlitching, setIsGlitching] = useState(false);

            useEffect(() => {
                const interval = setInterval(() => {
                    // 1. Start Glitch on old image
                    setIsGlitching(true);

                    // 2. Change image and rotation after 300ms (effect bridges the swap)
                    setTimeout(() => {
                        setCurrentIndex(prev => (prev + 1) % images.length);
                        setRotation((Math.random() * 16) - 8);
                    }, 300);

                    // 3. Stop glitch after total 800ms
                    setTimeout(() => setIsGlitching(false), 800);
                }, 3000);
                return () => clearInterval(interval);
            }, []);

            return (
                <div
                    className={isGlitching ? 'glitch-container glitch-active' : 'glitch-container'}
                    style={{
                        height: '70%',
                        aspectRatio: '1 / 1',
                        transform: `rotate(${rotation}deg)`,
                        transition: 'transform 0.1s ease-out'
                    }}
                >
                    <img
                        src={images[currentIndex]}
                        alt="Project"
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'cover',
                            filter: 'grayscale(100%)'
                        }}
                    />
                </div>
            );
        };

        // Render GridDistortion slideshow in header
        // Preloader Logic using Framer Motion
        const { motion, useSpring, useTransform, useMotionValue, AnimatePresence } = window.Motion;

        function DockItem({ children, onClick, mouseX, spring, distance, magnification, baseItemSize }) {
            const ref = useRef(null);

            const mouseDistance = useTransform(mouseX, val => {
                // Get the current center of this word
                const rect = ref.current?.getBoundingClientRect() ?? { left: 0, width: 0 };
                return val - (rect.left + rect.width / 2);
            });

            // scale factor (from 1 to approx 1.6)
            const scale = useTransform(mouseDistance, [-distance, 0, distance], [1, 1.6, 1]);
            const springScale = useSpring(scale, spring);

            return (
                <motion.div
                    ref={ref}
                    style={{
                        scale: springScale,
                        // This dynamic padding pushes neighbors as the word expands
                        paddingLeft: useTransform(springScale, s => `${(s - 1) * 40}px`),
                        paddingRight: useTransform(springScale, s => `${(s - 1) * 40}px`),
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: 'pointer',
                        whiteSpace: 'nowrap'
                    }}
                    onClick={onClick}
                    className="dock-item"
                >
                    {children}
                </motion.div>
            );
        }

        function Dock({
            items,
            className = '',
            spring = { mass: 0.1, stiffness: 150, damping: 12 },
            magnification = 60,
            distance = 150,
            panelHeight = 64,
            baseItemSize = 48
        }) {
            const mouseX = useMotionValue(Infinity);

            return (
                <div className="dock-outer">
                    <motion.div
                        onMouseMove={({ pageX }) => mouseX.set(pageX)}
                        onMouseLeave={() => mouseX.set(Infinity)}
                        className={`dock-panel ${className}`}
                    >
                        {items.map((item, index) => (
                            <DockItem
                                key={index}
                                onClick={item.onClick}
                                mouseX={mouseX}
                                spring={spring}
                                distance={distance}
                                magnification={magnification}
                                baseItemSize={baseItemSize}
                            >
                                <span className="dock-icon">{item.label}</span>
                            </DockItem>
                        ))}
                    </motion.div>
                </div>
            );
        }

        const NavigationDock = () => {
            const items = [
                { label: 'Início', onClick: () => window.scrollTo({ top: 0, behavior: 'smooth' }) },
                { label: 'Projetos', onClick: () => document.getElementById('work').scrollIntoView({ behavior: 'smooth' }) },
                { label: 'Contato', onClick: () => document.getElementById('contact').scrollIntoView({ behavior: 'smooth' }) },
            ];

            return (
                <Dock items={items} magnification={80} distance={200} />
            );
        };



        const STRIP_CHARS = "abcdefghijklmnopqrstuvwxyz.@#$%&*!?†§◆★●"; // Comic book swear symbols  
        const REPEATED_STRIP = STRIP_CHARS.repeat(4);

        function CharacterStrip({ targetChar, height, duration, delay }) {
            const baseIndex = STRIP_CHARS.indexOf(targetChar.toLowerCase());
            // Target is in the last set (3rd index 2) to ensure long scroll
            const targetIndex = baseIndex + (STRIP_CHARS.length * 3);

            // Start at a random position in the first set
            const startIndex = Math.floor(Math.random() * STRIP_CHARS.length);

            // Faster spring physics for ~1s settling time
            const springValue = useSpring(startIndex, { stiffness: 120, damping: 20 });

            useEffect(() => {
                const timeout = setTimeout(() => {
                    springValue.set(targetIndex);
                }, delay);
                return () => clearTimeout(timeout);
            }, [targetIndex, delay]);

            const y = useTransform(springValue, (latest) => -latest * height);

            return (
                <div style={{ height: height, overflow: 'hidden', position: 'relative', marginLeft: '-0.05em' }}>
                    <motion.div style={{ y, display: 'flex', flexDirection: 'column' }}>
                        {REPEATED_STRIP.split('').map((char, i) => (
                            <div key={i} className="counter-number" style={{ height: height, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                {char}
                            </div>
                        ))}
                    </motion.div>
                </div>
            );
        }

        const Preloader = () => {
            const [visible, setVisible] = useState(true);
            const targetText = "madebygabs.";

            const fontSize = window.innerWidth < 600 ? window.innerWidth * 0.12 : window.innerWidth * 0.08;
            const height = fontSize * 1.1;

            // Cleanup parent style (anti-flash) once React takes over
            useEffect(() => {
                const root = document.getElementById('preloader-root');
                if (root) {
                    root.style.background = 'transparent';
                    root.style.zIndex = 'auto';
                    root.removeAttribute('style');
                }
            }, []);

            useEffect(() => {
                document.body.classList.add('preloading');
                // Intro duration: 3.0s (approx 2s spin + 1s hold)
                const exitTimer = setTimeout(() => {
                    setVisible(false);
                    document.body.classList.remove('preloading');
                }, 3000);

                return () => {
                    clearTimeout(exitTimer);
                    document.body.classList.remove('preloading');
                };
            }, []);

            // Generate random delays for columns once on mount
            const columnDelays = useMemo(() => {
                const delays = [0, 0.1, 0.2, 0.3, 0.4, 0.5];
                // Shuffle array
                for (let i = delays.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [delays[i], delays[j]] = [delays[j], delays[i]];
                }
                return delays;
            }, []);

            // Staggered Slide Up animation - 6 columns + Text independent
            return (
                <>
                    {/* Background Columns */}
                    {[0, 1, 2, 3, 4, 5].map((index) => (
                        <motion.div
                            key={`col-${index}`}
                            className="preloader-overlay"
                            style={{
                                position: 'fixed',
                                top: 0,
                                left: `${index * (100 / 6)}%`,
                                width: `${100 / 6}%`,
                                height: '100%',
                                background: 'var(--accent-color)',
                                zIndex: 99999,
                            }}
                            initial={{ y: 0 }}
                            animate={{
                                y: visible ? 0 : '-100%',
                                pointerEvents: visible ? 'auto' : 'none'
                            }}
                            transition={{
                                duration: 0.8,
                                ease: "easeInOut",
                                delay: visible ? 0 : columnDelays[index] // Random delays
                            }}
                        />
                    ))}

                    {/* Text Container - Absolute on top */}
                    <motion.div
                        style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            width: '100%',
                            height: '100%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            zIndex: 100000,
                            pointerEvents: 'none'
                        }}
                        initial={{ y: 0 }}
                        animate={{
                            y: visible ? 0 : '-100%',
                        }}
                        transition={{
                            duration: 0.8,
                            ease: "easeInOut",
                            delay: visible ? 0 : 0.15 // Sync with middle columns
                        }}
                    >
                        <div style={{
                            display: 'flex',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 900,
                            fontSize: fontSize,
                            color: 'var(--bg-color)',
                            height: height,
                            overflow: 'hidden',
                            lineHeight: 1,
                            marginLeft: '0.05em'
                        }}>
                            {targetText.split('').map((char, i) => (
                                <CharacterStrip
                                    key={i}
                                    targetChar={char}
                                    height={height}
                                    delay={100 + i * 80}
                                    duration={1000}
                                />
                            ))}
                        </div>
                    </motion.div>
                </>
            );
        };

        ReactDOM.createRoot(document.getElementById('preloader-root')).render(<Preloader />);

        // Render GridDistortion slideshow in header
        ReactDOM.createRoot(document.getElementById('grid-distortion-root')).render(
            <GridDistortionSlideshow />
        );

        // Theme Management
        const getThemeColors = (theme) => {
            if (theme === 'theme2') {
                return {
                    bg: [0.004, 0.651, 0.424], // #01a66c Green
                    wave: [0.0, 0.0, 0.0]      // Black Wave
                };
            }
            if (theme === 'theme3') {
                return {
                    bg: [0.0, 0.0, 0.0],       // #000000 Black
                    wave: [1.0, 1.0, 1.0]      // White Wave
                };
            }
            // Default Theme 1 (Risograph)
            return {
                bg: [0.957, 0.906, 0.831], // #F4E7D4 Cream
                wave: [0.0, 0.0, 0.0]      // Black Wave
            };
        };

        const ThemeSwitcher = () => {
            const [currentTheme, setCurrentTheme] = useState(() => localStorage.getItem('site-theme') || 'theme1');

            const setTheme = (theme) => {
                setCurrentTheme(theme);
                localStorage.setItem('site-theme', theme);
                document.documentElement.setAttribute('data-theme', theme);

                window.dispatchEvent(new CustomEvent('theme-change', {
                    detail: { theme }
                }));
            };

            return (
                <div className="theme-switcher" style={{
                    position: 'fixed',
                    bottom: '2rem',
                    right: '1.5rem',
                    zIndex: 10001,
                    display: 'flex',
                    gap: '12px',
                    transition: 'all 0.4s ease'
                }}>
                    {/* Theme 1: Cream */}
                    <button
                        onClick={() => setTheme('theme1')}
                        aria-label="Theme 1"
                        style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '50%',
                            background: '#F4E7D4',
                            border: currentTheme === 'theme1' ? '3px solid #ed2d92' : '1px solid rgba(0,0,0,0.1)',
                            cursor: 'pointer',
                            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                            transition: 'transform 0.2s',
                            transform: currentTheme === 'theme1' ? 'scale(1.1)' : 'scale(1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 'bold',
                            color: '#000000',
                            fontSize: '14px'
                        }}
                    >1</button>
                    {/* Theme 2: Green */}
                    <button
                        onClick={() => setTheme('theme2')}
                        aria-label="Theme 2"
                        style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '50%',
                            background: '#01a66c',
                            border: currentTheme === 'theme2' ? '3px solid #ed2d92' : '1px solid rgba(0,0,0,0.1)',
                            cursor: 'pointer',
                            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                            transition: 'transform 0.2s',
                            transform: currentTheme === 'theme2' ? 'scale(1.1)' : 'scale(1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 'bold',
                            color: '#ffffff',
                            fontSize: '14px'
                        }}
                    >2</button>
                    {/* Theme 3: Black/Pink */}
                    <button
                        onClick={() => setTheme('theme3')}
                        aria-label="Theme 3"
                        style={{
                            width: '32px',
                            height: '32px',
                            borderRadius: '50%',
                            background: '#000000',
                            border: currentTheme === 'theme3' ? '3px solid #ed2d92' : '1px solid rgba(255,255,255,0.2)',
                            cursor: 'pointer',
                            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
                            transition: 'transform 0.2s',
                            transform: currentTheme === 'theme3' ? 'scale(1.1)' : 'scale(1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontFamily: 'var(--font-heading)',
                            fontWeight: 'bold',
                            color: '#ffffff',
                            fontSize: '14px'
                        }}
                    >3</button>
                </div>
            );
        };

        // Dither Background Effect Component


        const DitherBackground = ({
            waveSpeed = 0.05,
            waveFrequency = 3,
            waveAmplitude = 0.3,
            colorNum = 4,
            pixelSize = 2,
            enableMouseInteraction = true,
            mouseRadius = 0.3
        }) => {
            const containerRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;
                const container = containerRef.current;

                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                const vertexShader = `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const fragmentShader = `
                    precision highp float;
                    uniform vec2 resolution;
                    uniform float time;
                    uniform float waveSpeed;
                    uniform float waveFrequency;
                    uniform float waveAmplitude;
                    uniform vec3 waveColor;
                    uniform vec3 backgroundColor;
                    uniform vec2 mousePos;
                    uniform int enableMouseInteraction;
                    uniform float mouseRadius;
                    uniform float colorNum;
                    uniform float pixelSize;

                    vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                    vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

                    float cnoise(vec2 P) {
                        vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);
                        vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);
                        Pi = mod289(Pi);
                        vec4 ix = Pi.xzxz, iy = Pi.yyww;
                        vec4 fx = Pf.xzxz, fy = Pf.yyww;
                        vec4 i = permute(permute(ix) + iy);
                        vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;
                        vec4 gy = abs(gx) - 0.5;
                        vec4 tx = floor(gx + 0.5);
                        gx = gx - tx;
                        vec2 g00 = vec2(gx.x, gy.x), g10 = vec2(gx.y, gy.y);
                        vec2 g01 = vec2(gx.z, gy.z), g11 = vec2(gx.w, gy.w);
                        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11));
                        g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;
                        float n00 = dot(g00, vec2(fx.x, fy.x)), n10 = dot(g10, vec2(fx.y, fy.y));
                        float n01 = dot(g01, vec2(fx.z, fy.z)), n11 = dot(g11, vec2(fx.w, fy.w));
                        vec2 fade_xy = fade(Pf.xy);
                        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                        return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);
                    }

                    float fbm(vec2 p) {
                        float value = 0.0, amp = 1.0, freq = waveFrequency;
                        for (int i = 0; i < 4; i++) {
                            value += amp * abs(cnoise(p));
                            p *= freq;
                            amp *= waveAmplitude;
                        }
                        return value;
                    }

                    float pattern(vec2 p) {
                        vec2 p2 = p - time * waveSpeed;
                        return fbm(p + fbm(p2));
                    }

                    // Bayer 8x8 dithering
                    float bayer8(vec2 pos) {
                        ivec2 p = ivec2(mod(pos, 8.0));
                        int index = p.x + p.y * 8;
                        float matrix[64];
                        matrix[0]=0.0; matrix[1]=48.0; matrix[2]=12.0; matrix[3]=60.0; matrix[4]=3.0; matrix[5]=51.0; matrix[6]=15.0; matrix[7]=63.0;
                        matrix[8]=32.0; matrix[9]=16.0; matrix[10]=44.0; matrix[11]=28.0; matrix[12]=35.0; matrix[13]=19.0; matrix[14]=47.0; matrix[15]=31.0;
                        matrix[16]=8.0; matrix[17]=56.0; matrix[18]=4.0; matrix[19]=52.0; matrix[20]=11.0; matrix[21]=59.0; matrix[22]=7.0; matrix[23]=55.0;
                        matrix[24]=40.0; matrix[25]=24.0; matrix[26]=36.0; matrix[27]=20.0; matrix[28]=43.0; matrix[29]=27.0; matrix[30]=39.0; matrix[31]=23.0;
                        matrix[32]=2.0; matrix[33]=50.0; matrix[34]=14.0; matrix[35]=62.0; matrix[36]=1.0; matrix[37]=49.0; matrix[38]=13.0; matrix[39]=61.0;
                        matrix[40]=34.0; matrix[41]=18.0; matrix[42]=46.0; matrix[43]=30.0; matrix[44]=33.0; matrix[45]=17.0; matrix[46]=45.0; matrix[47]=29.0;
                        matrix[48]=10.0; matrix[49]=58.0; matrix[50]=6.0; matrix[51]=54.0; matrix[52]=9.0; matrix[53]=57.0; matrix[54]=5.0; matrix[55]=53.0;
                        matrix[56]=42.0; matrix[57]=26.0; matrix[58]=38.0; matrix[59]=22.0; matrix[60]=41.0; matrix[61]=25.0; matrix[62]=37.0; matrix[63]=21.0;
                        return matrix[index] / 64.0;
                    }

                    vec3 dither(vec3 color, vec2 fragCoord, float pSize) {
                        vec2 scaledCoord = floor(fragCoord / pSize);
                        float threshold = bayer8(scaledCoord) - 0.25;
                        float step = 1.0 / (colorNum - 1.0);
                        color += threshold * step;
                        color = clamp(color - 0.2, 0.0, 1.0);
                        return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
                    }

                    void main() {
                        vec2 uv = gl_FragCoord.xy / resolution.xy;
                        vec2 uvOriginal = uv;
                        uv -= 0.5;
                        uv.x *= resolution.x / resolution.y;
                        float f = pattern(uv);
                        
                        if (enableMouseInteraction == 1) {
                            vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);
                            mouseNDC.x *= resolution.x / resolution.y;
                            float dist = length(uv - mouseNDC);
                            float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);
                            // Push effect away from mouse - reduce pattern intensity
                            f *= (1.0 - effect * 0.8);
                        }
                        
                        // Mix background color with wave color
                        vec3 col = mix(backgroundColor, waveColor, f);
                        col = dither(col, gl_FragCoord.xy, pixelSize);
                        
                        gl_FragColor = vec4(col, 1.0);
                    }
                `;

                const getThemeColors = (themeName) => {
                    const themes = {
                        theme1: { bg: [0.957, 0.906, 0.831], wave: [0, 0, 0] },
                        theme2: { bg: [0.004, 0.651, 0.424], wave: [0, 0, 0] },
                        theme3: { bg: [0, 0, 0], wave: [1, 1, 1] }
                    };
                    return themes[themeName] || themes.theme1;
                };

                const savedTheme = localStorage.getItem('site-theme') || 'theme1';
                const initialColors = getThemeColors(savedTheme);
                const uniforms = {
                    resolution: { value: new THREE.Vector2() },
                    time: { value: 0 },
                    waveSpeed: { value: waveSpeed },
                    waveFrequency: { value: waveFrequency },
                    waveAmplitude: { value: waveAmplitude },
                    waveColor: { value: new THREE.Vector3(...initialColors.wave) },
                    backgroundColor: { value: new THREE.Vector3(...initialColors.bg) },
                    mousePos: { value: new THREE.Vector2() },
                    enableMouseInteraction: { value: enableMouseInteraction ? 1 : 0 },
                    mouseRadius: { value: mouseRadius },
                    colorNum: { value: colorNum },
                    pixelSize: { value: pixelSize }
                };

                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                const handleResize = () => {
                    const rect = container.getBoundingClientRect();
                    renderer.setSize(rect.width, rect.height);
                    uniforms.resolution.value.set(rect.width * renderer.getPixelRatio(), rect.height * renderer.getPixelRatio());
                };

                window.addEventListener('resize', handleResize);
                handleResize();

                const handleMouseMove = e => {
                    const rect = container.getBoundingClientRect();
                    const dpr = renderer.getPixelRatio();
                    uniforms.mousePos.value.set((e.clientX - rect.left) * dpr, (e.clientY - rect.top) * dpr);
                };

                window.addEventListener('mousemove', handleMouseMove);

                // Listen for theme changes to update uniforms
                const handleThemeChange = (e) => {
                    const newColors = getThemeColors(e.detail.theme);
                    uniforms.backgroundColor.value.set(...newColors.bg);
                    uniforms.waveColor.value.set(...newColors.wave);
                };
                window.addEventListener('theme-change', handleThemeChange);

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    uniforms.time.value += 0.016;
                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('theme-change', handleThemeChange);
                    renderer.dispose();
                    geometry.dispose();
                    material.dispose();
                };
            }, [waveSpeed, waveFrequency, waveAmplitude, colorNum, pixelSize, enableMouseInteraction, mouseRadius]);

            return <div ref={containerRef} className="dither-container" />;
        };

        ReactDOM.createRoot(document.getElementById('dock-root')).render(<NavigationDock />);

        // Render Theme Switcher
        const themeRoot = document.createElement('div');
        document.body.appendChild(themeRoot);
        ReactDOM.createRoot(themeRoot).render(<ThemeSwitcher />);

        // Render Dither background
        ReactDOM.createRoot(document.getElementById('dither-bg-root')).render(
            <DitherBackground
                waveSpeed={0.05}
                waveFrequency={3}
                waveAmplitude={0.3}
                colorNum={4}
                pixelSize={4}
                enableMouseInteraction={true}
                mouseRadius={0.45}
            />
        );
    </script>

    <script src="script.js"></script>
</body>

</html>